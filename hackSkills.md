#  BOF, hack skills

## BOF란?  
BOF(Buffer OverFlow)는 프로그램의 함수가 가진 취약점을 이용한 공격방법이다.  
예를들어 get(), strcpy(), scnaf()등 입력값의 길이를 고려하지않고 들어온 값을 모두 버퍼, 스택에 넣는다. 이 과정에서 저장할 변수 주소 이외의 곳에 데이터를 침범하게 된다.  
다른곳의 데이터를 변경함으로써 프로그램에서 쉘을 실행하거나, 권한을 얻어오는 방법으로 활용이 가능하다.  

우선 BOF가 작동하는 원리를 파악하기 위해서는 메모리의 작동 방식을 아는것이 중요하다.  
  
> 스택 (높은주소)   
> 힙  
> 데이터  
> 코드 (낮은주소)  

함수가 실행되면 스택에 하나의 영역을 위처럼 만들고. 그곳의
지역변수들은 스택에 저장된다(높은 주소에서 낮은 주소로 크기를 확장한다). 위의 함수들로 스택에 있는 버퍼에 저장을 하게 되면 함수가 끝났을 때, 이전 함수로 돌아가기위해 저장된 주소를 변경하게 되고 그것으로 다른 함수, 혹은 다른일을 작동시킨다.

## BOF 방법들
</br>  

### NOP Sled  
NOP(No OPeration)의 약자로, 명령어이다. 이 명령어에 도달하면 아무일도 하지 않고 다음주소로(다음 명령어)로 가서 작동하게 한다.  
이것은 '0x90'의 값을 가지고 있다.  
쉘코드와 많은 NOP를 붙여서 사용하고 이는, 많은 주소를 확보해야 한다는 특징이 있고, 쉘코드의 위치를 정확하게 지정해주지 않아도 된다는 장점이 있다.  
</br>
예를들어, <쉘코드>[NOP][NOP][NOP][NOP][NOP][NOP][NOP][NOP] 처럼 주소를 할당해주고 NOP가 있을것으로 예상되는 주소를 리턴주소로 만들어준다. 그러면 NOP를 타고내려가 쉘코드가 작동되는 방식이다.

>export SHELLCODE=\`python -c "print '\x90' * 100 + '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80'"`   

위 코드는 환경변수를 파이썬을 이용하여 NOP를 100개 + 쉘코드를 넣어준다.  
getenv()로 환경변수의 위치를 확인할 수 있다.
</br>
</br>  

### GOT overwriter
코딩할때, 많은 함수를 이용한다. 함수를 프로그램내에 코딩할 때가 있지만, 외부의 라이브러리등을 참고하여 코딩을 할 수 있다.  
이때, 컴파일 후 링크과정을 거쳐 실행파일로 만들어지게 되는데 링크 방식이 Dynamic Link라면 프로그램 내에서 함수를 호출할 때 외부를 참조하고 참조할 때에 PLT&GOT를 사용한다.  
PLT는 GOT를 가르키고 GOT는 실제 함수를 가르킨다. 여기서 GOT주소를 바꾸어 다른 함수를 작동하도록 만드는 방법이다.  
예를들어서 
>p system 으로 system함수의 주소를 얻을 수 있다.   
>set으로 plt가 가르키는 got 값을 변경한다.  
>ex) set *plt값 = system함수 주소  

</br>
</br>

### RTL
RTL(Return to  libc)   
스택에서 쉘코드를 사용하지 못하도록하는 메모리 보호기법 때문에 안되는 경우가 생김 N x bit 메모리 보호기법 (never excutable)  
이것을 우회하는 방법으로 RTL이 사용됨.  
>함수 하나의 리턴 주소를 system()함수로 한다.  
>그러면 system함수의 프롤로그가 진행된다. (push1번)  
>종료할 때 leave, ret가 진행된다. (pop2번)  
>이렇게 pop이 한번 더 이루어지게 된다.(call을 했을경우push를 하는데 call을 하지 않았음)  
>결과적으로 처음의 ret주소보다 한칸 높은 스택영역으로 돌아가게 된다.  
>이렇게 보면 처음ret+1 주소는 system()의 ret가 되고 처음ret+2는 system()의 argument가 된다. 그래서 우리는 이 값을 변경하게 된다.

gdb에서 빈쉘 주소찾기:
find &system,+99999999, "/bin/sh"  
(system주소로부터 99999999의 범위안에 /bin/sh이 있는지 찾아라)  

값 변경하는 입력 예시:
>(python -c "print 'x' * 36 + '\xe0\xf4\xe0\xf7' + 'aaaa' + '\x2f\x21\xf6\xf7'";cat) | ./rtl
>버퍼+SFP(36) + 시스템 주소 + 시스템의 리턴주소 + 시스템의 argument(bin/sh)

</br>
</br>

## UAF
malloc처럼 A크기로 동적할당 후 해재하고 다시 같은A크기로 할당을 하면  
위의 두 할당은 같은 주소를 할당해주게 된다.  
여러가지 방법으로 이 주소에 접근하면 이전에 쓰던 데이터 값을 가져올 수도 있고 다르게 활용할 수 있게된다.

</br>
</br>

## SFP overwrite
Leave ret을 잘 이용하는것이다.  
>sfp를 버퍼-8 주소로 해놓으면
leave에 의해서  
ebp가 버퍼-4 로 가게 되고 ret이 버퍼로 간다,
버퍼에 쉘코드를 넣고 실행시킨다.

버퍼 바로앞 주소에는 버퍼의 주소를 담고있다. (leave 하는 순간에)
